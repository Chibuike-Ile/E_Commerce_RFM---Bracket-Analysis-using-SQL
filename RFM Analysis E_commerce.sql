select * from e_commerce;
select sum(`Quantity Ordered`) as'Total Quantity ordered' from e_commerce;
select round(sum(Sales), 2) as "Total Sales for May" from e_commerce where Month = "05";
select product, round(sum(sales), 2) as "Total Sales" from e_commerce group by  product;
select product from e_commerce where `Time of Day` = "Evening";
select `Product Category`, round(sum(Sales), 2) as "Total Sales" from e_commerce group by `Product Category`;
select product, sum(`Quantity Ordered`) as "Total Quantity" from e_commerce group by Product;
select city, sum(`Quantity Ordered`) as "Total Quantity" from e_commerce group by city; 
select product from e_commerce where `Product Category` = 'Electronics';
select Hour as "Hour of Day", round(sum(Sales), 2) as "Total Sales" from e_commerce group by Hour;
select product, round(avg(`Price Each`), 0) as "Average price" from e_commerce group by product;
select Month, round(sum(Sales), 2) as "Total Sales" from e_commerce group by Month;
select `Order ID`, `Quantity Ordered` from e_commerce where `Quantity Ordered`> 5;
select product, max(Sales) as "Maxnimun Sales" from e_commerce group by product;
select `Order ID`,  `Price Each` from e_commerce where `Price Each` > "800";
select distinct(product) , sales from e_commerce order by sales desc limit 5;

select max(`Order Date`) FROM e_commerce;
--- RFM Analysis.
set @today  = "2020-01-01";
select max(Date) from e_commerce;
--- To get the most recent purchase date of each customer.
select `Purchase Address`as Customers_Address, max(Date) as Most_recent_purchase_date,
@today as Today_date
from e_commerce group by `Purchase Address`;

--- We need the date different from our set todays date, hence we use Datediff. 

select `Purchase Address`as Customers_Address, max(Date) as Most_recent_purchase_date,
@today as Todays_date,
datediff(@today, Max(Date)) as Recency_score
from e_commerce group by `Purchase Address`;

    
--- I used this to change date column form text data type to date date type.

ALTER TABLE e_commerce CHANGE `Date` Date_text VARCHAR(255);
ALTER TABLE e_commerce ADD COLUMN `Date` DATE;
SELECT @@sql_safe_updates;
SET SQL_SAFE_UPDATES = 0;
UPDATE e_commerce 
SET Date = STR_TO_DATE(Date, '%Y/%m/%d');

ALTER TABLE e_commerce DROP COLUMN Date_text;
alter table e_commerce drop column Date_parsed;

--- to calculate the frequency and monetary value.

select `Purchase Address`as Customers_Address, max(Date) as Most_recent_purchase_date,
datediff(@today, Max(Date)) as Recency_score,
count(`Order ID`) as Frequency_score,
round(sum(Sales), 2) as Monetary_score
from e_commerce group by `Purchase Address`;

--- for RFM Analysis
--- first  we convert the result above to CTE table

CREATE TEMPORARY TABLE Base AS 
     select `Purchase Address`as Customers_Address, 
	 datediff(@today, Max(Date)) as Recency_score,
     count(`Order ID`) as Frequency_score,
     round(sum(Sales), 2) as Monetary_score
     from e_commerce group by `Purchase Address`;
     


--- TO Group the scores into brackets, we group it into 5 ( 5 is the highest and 1 is the lowest)

select Customers_Address, Recency_score, Frequency_score, Monetary_score,
ntile(5) over (order by Recency_score desc) as R,
ntile(5) over (order by Frequency_score asc) as F,
ntile(5) over (order by Monetary_score asc) as M
from Base;

--- for RFM Analysis we need to create another temporary table called RFM_Score
create temporary table RFM_Score as
select Customers_Address, Recency_score, Frequency_score, Monetary_score,
ntile(5) over (order by Recency_score desc) as R,
ntile(5) over (order by Frequency_score asc) as F,
ntile(5) over (order by Monetary_score asc) as M
from Base;



 select Customers_Address, 
 concat_ws( - R,   F, -  M ) as RFM_Cell,
 round(((R + F + M) / 3), 2) as Avg_RFM_Socres
 from RFM_Score;
 
 -- To answer questions like how much revenue each bucket generate and the average revenue
 
 --- We need to get the identifier using the query below and round it zero decimal so it gives integer  
 
 select round(((R + F + M) / 3), 0) as RFM_Grouping from RFM_Score;
 
 --- we need to know the number of customers that falls in each group
 
 select 
 round(((R + F + M) / 3), 0) as RFM_Grouping,
 count(Customers_Address) as Customer_Count
 from RFM_Score group by RFM_Grouping;
 
 --- We need to know the revenue and average revenue generated by each group
 
 select round(((R + F + M) / 3), 0) as RFM_Grouping,
 count(RFM_Score.Customers_Address) as No_Of_Customers,
 round(sum(Base.Monetary_score), 2) as Total_Sales,
 round(sum(Base.Monetary_score) / count(RFM_Score.Customers_Address), 2) as Avg_Sales_per_Customer 
 from RFM_Score 
 inner join Base on Base.Customers_Address = RFM_Score.Customers_Address 
 group by RFM_Grouping
 order by RFM_Grouping desc;
 
 --- Basket Analysis
--- Determine which products are frequently ordered together by the same customers. 

select * from e_commerce;
select
	a.`Purchase Address` as Customer_Address,
    a.`Product` as Product_A,
    b.`Product` as Product_B,
    COUNT(*) as Number_Of_Times_Bought_Together
from
    e_commerce a
join
    e_commerce b
    on a.`Order ID` = b.`Order ID`
    and a.`Product` < b.`Product`  -- Avoid duplicate & same-product pairs
group by 
    Customer_Address, Product_A, Product_B
order by 
    Number_Of_Times_Bought_Together desc
limit 20;

select
	a.`Purchase Address` as Customer_Address,
    a.`Product` as Product_A,
    b.`Product` as Product_B,
    COUNT(*) as Number_Of_Times_Bought_Together
from
    e_commerce a
join
    e_commerce b
    on a.`Order ID` = b.`Order ID`
    and a.`Product` < b.`Product`  
group by 
    Customer_Address, Product_A, Product_B
order by 
    Number_Of_Times_Bought_Together desc
    limit 100;


--- The query below gives a view of orders with multiple items — great for exporting or deeper analysis.

SELECT 
    `Order ID`,
    GROUP_CONCAT(DISTINCT `Product` ORDER BY `Product` SEPARATOR ', ') AS Products_Bought,
    COUNT(DISTINCT `Product`) AS Num_Products
FROM 
    e_commerce
GROUP BY 
    `Order ID`
HAVING 
    Num_Products > 1;





